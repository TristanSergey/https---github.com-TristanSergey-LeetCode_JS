// По оси X расположен одномерный сад.Сад начинается в точке 0 и заканчивается в точке n. (т.е.длина сада равна n).
// В саду имеется n + 1 кранов, расположенных в точках[0, 1, ..., n].
// Учитывая целое число n и целочисленный массив ranges длиной n + 1, где ranges[i](с индексом 0) означает,
// что i - й кран может поливать область[i - ranges[i], i + ranges[i]], если оно было открыто.
// Верните минимальное количество кранов, которые должны быть открыты для полива всего сада.Если сад нельзя полить, верните - 1.
// 1326
// --  Создавайте интервалы области, охватываемой каждым касанием, сортируйте интервалы по левому краю.
// --  Нам нужно покрыть интервал [0, n]. мы можем начать с первого интервала и из всех пересекающихся с ним интервалов выбрать тот,
//     который охватывает самую дальнюю точку вправо.
// --  Что делать, если между интервалами есть незаполненный пробел? нам следует остановиться и вернуть -1, поскольку существует некоторый интервал, который невозможно охватить.

//n = 6, ranges = [3, 4, 1, 1, 0, 0, 2]
n = 35, ranges = [1, 0, 4, 0, 4, 1, 4, 3, 1, 1, 1, 2, 1, 4, 0, 3, 0, 3, 0, 3, 0, 5, 3, 0, 0, 1, 2, 1, 2, 4, 3, 0, 1, 0, 5, 2]
n = 11, ranges = [2, 1, 2, 1, 2, 4, 3, 0, 1, 0, 5, 2]
n = 97, ranges = [1, 5, 3, 1, 4, 5, 5, 1, 2, 0, 2, 2, 4, 3, 0, 0, 1, 4, 5, 5, 0, 3, 5, 1, 1, 0, 0, 0, 4, 1, 1, 1, 0, 4, 4, 1, 0, 0, 2, 5, 5, 4, 4, 4, 2, 4, 3, 4, 4, 2, 3, 4, 0, 2, 0, 1, 0, 4, 2, 3, 0, 0, 0, 1, 5, 2, 0, 2, 4, 4, 3, 3, 0, 0, 3, 1, 1, 1, 4, 2, 5, 2, 3, 1, 0, 1, 0, 2, 4, 3, 4, 0, 2, 4, 1, 1, 2, 5]
var minTaps = function (n, ranges) {
    const dp = new Array(n + 1).fill(Infinity);
    dp[0] = 0;

    for (let i = 0; i < ranges.length; i++) {
        const ahead = Math.max(0, i - ranges[i]);
        const end = Math.min(n, i + ranges[i])
        for (let j = ahead + 1; j <= end; j++) {
            //  console.log(i + ' - i - ' + ranges[i] + ' - ranges[i] - ' + j + ' - j - ' + ranges[j] + ' -  ranges[j] -')
            dp[j] = Math.min(dp[j], dp[ahead] + 1);
            //  console.log(dp)
        }
    }

    return dp[n] !== Infinity ? dp[n] : -1;





};

console.log(minTaps(n, ranges))






