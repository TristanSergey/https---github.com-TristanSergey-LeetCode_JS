// Вам дан список авиабилетов, где билеты[i] = [fromi, toi] обозначают аэропорты вылета 
// и прибытия одного рейса. Восстановите маршрут в порядке и верните его.
// Все билеты принадлежат человеку, который вылетает из аэропорта «JFK», 
// поэтому маршрут должен начинаться с «JFK». Если существует несколько допустимых маршрутов, 
// вам следует вернуть маршрут с наименьшим лексическим порядком при чтении как одной строки.
// Например, маршрут["JFK", "LGA"] имеет меньший лексический порядок, чем["JFK", "LGB"].
// Вы можете предположить, что все билеты составляют хотя бы один действительный маршрут.
// Вы должны использовать все билеты один и только один раз.
// 332

tickets = [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]


var findItinerary = function (tickets) {

    const graph = {}; // Создаем объект для представления графа
    const answer = []; // Массив для хранения ответа

    // Заполняем граф данными из билетов
    for (const [from, to] of tickets) {
        if (!graph[from]) {
            graph[from] = [];
        }
        graph[from].push(to);
    }

    // Сортируем списки аэропортов в графе в лексикографическом порядке
    for (const from in graph) {
        graph[from].sort();
    }

    console.log(graph)

    // Функция для обхода графа
    function search(node) {
        const dest = graph[node];

        while (dest && dest.length > 0) {
            // Берем первый аэропорт из списка и удаляем его
            const nextDest = dest.shift();
            search(nextDest); // Рекурсивно переходим в следующий аэропорт
        }

        // Когда у данного аэропорта заканчиваются перелеты, добавляем его в ответ
        answer.unshift(node);
    }

    // Начинаем обход с начального аэропорта "JFK"
    search("JFK");

    return answer;


};


console.log(findItinerary(tickets))